<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GSPlay</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%2306b6d4' rx='15' width='100' height='100'/><text x='50' y='70' font-size='60' text-anchor='middle' fill='white'>G</text></svg>">
  <style>
    :root {
      --bg-base: #0a0a0a;
      --bg-surface: #141414;
      --bg-secondary: #1a1a1a;
      --bg-tertiary: #252525;
      --bg-hover: #1a1a1a;
      --bg-input: #0f0f0f;
      --border: #2a2a2a;
      --text-primary: #e5e5e5;
      --text-secondary: #737373;
      --text-tertiary: #525252;
      --accent: #06b6d4;
      --accent-hover: #22d3ee;
      --accent-muted: rgba(6,182,212,0.12);
      --accent-subtle: rgba(6,182,212,0.18);
      --success: #22c55e;
      --success-muted: rgba(34,197,94,0.12);
      --success-subtle: rgba(34,197,94,0.18);
      --danger: #ef4444;
      --danger-muted: rgba(239,68,68,0.12);
      --danger-subtle: rgba(239,68,68,0.18);
      --input-height: 28px;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: var(--bg-base); }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent); }
    * { scrollbar-width: thin; scrollbar-color: #333 var(--bg-base); }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-base);
      color: var(--text-primary);
      min-height: 100vh;
      font-size: 13px;
      line-height: 1.4;
      -webkit-font-smoothing: antialiased;
    }

    header {
      background: var(--bg-surface);
      padding: 8px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    header h1 { font-size: 15px; font-weight: 600; color: var(--text-primary); }
    #status { font-size: 11px; color: var(--text-secondary); }

    main { max-width: 1200px; margin: 0 auto; padding: 12px 16px; }

    .error {
      background: rgba(239,68,68,0.1);
      color: #f87171;
      padding: 6px 10px;
      border-radius: 4px;
      margin-bottom: 10px;
      font-size: 12px;
      display: none;
    }

    .card {
      background: var(--bg-surface);
      border-radius: 6px;
      margin-bottom: 10px;
    }

    .card-header {
      padding: 8px 12px;
      background: rgba(255,255,255,0.02);
      font-weight: 600;
      font-size: 11px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .card-body { padding: 10px 12px; }

    /* Unified inner container for scrollable content */
    .card-inner {
      background: var(--bg-input);
      border-radius: 4px;
      overflow-y: auto;
      max-height: 300px;
      padding: 6px;
    }

    .card-inner.compact { max-height: 200px; }

    .card-inner .empty-state {
      padding: 18px;
      text-align: center;
      color: var(--text-tertiary);
      font-size: 12px;
    }

    .form-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: flex-end;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    label {
      font-size: 10px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    input, select {
      height: var(--input-height);
      padding: 0 8px;
      font-size: 12px;
      border-radius: 4px;
      background: var(--bg-input);
      border: none;
      color: var(--text-primary);
      transition: background 0.15s;
    }

    select option {
      background: var(--bg-surface);
      color: var(--text-primary);
    }

    input:focus, select:focus {
      outline: none;
      background: var(--accent-muted);
    }

    input::placeholder { color: var(--text-tertiary); }

    /* Toggle buttons */
    .toggle-btn {
      height: var(--input-height);
      padding: 0 10px;
      font-size: 11px;
      border-radius: 4px;
      background: var(--bg-input);
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s;
    }

    .toggle-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
    .toggle-btn.active { background: var(--accent-muted); color: var(--accent); }

    /* Buttons - ghost style matching the dark UI */
    button {
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      border: none;
      transition: all 0.15s;
    }

    button:active { transform: scale(0.97); }
    button:disabled { opacity: 0.4; cursor: not-allowed; }

    /* Primary - accent color, ghost style */
    .btn-primary {
      background: var(--accent-muted);
      color: var(--accent);
    }
    .btn-primary:hover { background: var(--accent-subtle); }

    /* Success - for launch/open actions */
    .btn-success {
      background: var(--success-muted);
      color: var(--success);
    }
    .btn-success:hover { background: var(--success-subtle); }

    /* Danger - for stop/delete actions */
    .btn-danger {
      background: var(--danger-muted);
      color: #f87171;
    }
    .btn-danger:hover { background: var(--danger-subtle); }

    /* Secondary - neutral */
    .btn-secondary {
      background: var(--bg-input);
      color: var(--text-secondary);
    }
    .btn-secondary:hover { background: var(--bg-hover); color: var(--text-primary); }

    .btn-sm { padding: 4px 8px; font-size: 10px; }

    .mono { font-family: 'SF Mono', Consolas, monospace; font-size: 11px; color: var(--text-secondary); }

    /* Status badges */
    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .badge-running { background: rgba(6,182,212,0.15); color: var(--accent); }
    .badge-starting { background: rgba(234,179,8,0.15); color: #fde047; }
    .badge-stopped { background: rgba(255,255,255,0.05); color: var(--text-secondary); }
    .badge-failed { background: rgba(239,68,68,0.15); color: #f87171; }
    .badge-orphaned { background: rgba(139,92,246,0.15); color: #c4b5fd; }

    /* File browser */
    .path-bar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      margin-bottom: 10px;
      background: var(--bg-input);
      border-radius: 4px;
    }

    .breadcrumb {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      overflow: hidden;
    }

    .breadcrumb a {
      color: var(--accent);
      text-decoration: none;
      cursor: pointer;
      white-space: nowrap;
    }

    .breadcrumb a:hover { color: var(--accent-hover); }
    .breadcrumb span { color: var(--text-tertiary); }

    .file-item {
      display: flex;
      align-items: center;
      padding: 6px 8px;
      cursor: pointer;
      transition: background 0.1s;
      border-radius: 3px;
      margin-bottom: 2px;
    }

    .file-item:hover { background: var(--bg-hover); }
    .file-item.disabled { opacity: 0.4; cursor: default; }
    .file-item.disabled:hover { background: transparent; }
    .file-item.ply-folder { background: var(--accent-muted); }
    .file-item.ply-folder:hover { background: rgba(6,182,212,0.18); }
    .file-item:last-child { margin-bottom: 0; }

    .file-icon { width: 20px; font-size: 13px; }
    .file-name { flex: 1; font-size: 12px; }
    .file-meta { font-size: 10px; color: var(--text-tertiary); margin-right: 8px; }
    .file-actions { display: flex; gap: 4px; }

    /* Instance items - same style as file items */
    .instance-item {
      display: flex;
      align-items: center;
      padding: 6px 8px;
      cursor: pointer;
      transition: background 0.1s;
      border-radius: 3px;
      margin-bottom: 2px;
      gap: 8px;
    }

    .instance-item:hover { background: var(--bg-hover); }
    .instance-item.selected { background: var(--accent-muted); }
    .instance-item:last-child { margin-bottom: 0; }

    .instance-name { font-size: 12px; min-width: 120px; }
    .instance-meta { font-size: 11px; color: var(--text-tertiary); flex: 1; font-family: 'SF Mono', Consolas, monospace; }
    .instance-actions { display: flex; gap: 6px; align-items: center; }

    /* Button groups - connected buttons */
    .btn-group {
      display: inline-flex;
      border-radius: 4px;
      overflow: hidden;
    }
    .btn-group button {
      border-radius: 0;
      margin: 0;
    }
    .btn-group button:first-child { border-radius: 4px 0 0 4px; }
    .btn-group button:last-child { border-radius: 0 4px 4px 0; }
    .btn-group button:only-child { border-radius: 4px; }
    .btn-group .btn-divider {
      width: 1px;
      background: rgba(255,255,255,0.1);
    }

    /* Icon button in groups */
    .btn-group .btn-icon {
      width: 26px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .btn-group .btn-icon svg {
      width: 11px;
      height: 11px;
      fill: currentColor;
      opacity: 0.8;
    }
    .btn-group .btn-icon:hover svg { opacity: 1; }

    .actions { display: flex; gap: 5px; }
    .text-muted { color: var(--text-tertiary); }
    .text-truncate {
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Empty states - used outside card-inner (e.g. error messages) */
    .empty-state {
      color: var(--text-tertiary);
      font-size: 12px;
    }

    /* Console content */
    .console-content {
      padding: 4px 6px;
      font-family: 'SF Mono', Consolas, 'Liberation Mono', monospace;
      font-size: 11px;
      line-height: 1.6;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .console-content .log-line { color: var(--text-secondary); }
    .console-content .log-line.error { color: #f87171; }
    .console-content .log-line.warning { color: #fde047; }
    .console-content .log-line.info { color: var(--accent); }

    .console-content .console-empty {
      padding: 12px;
      text-align: center;
    }

    .console-status {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-tertiary);
      margin-right: 6px;
      vertical-align: middle;
      position: relative;
      top: -1px;
    }

    .console-status.streaming { background: var(--success); animation: pulse 1.5s infinite; }
    .console-status.error { background: var(--danger); }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .console-instance-name {
      color: var(--accent);
      font-weight: normal;
      text-transform: none;
      letter-spacing: normal;
    }

    /* Collapsible card */
    .card-header.collapsible {
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .card-header.collapsible:hover { background: rgba(255,255,255,0.04); }
    .card-header .collapse-icon {
      font-size: 10px;
      color: var(--text-tertiary);
      transition: transform 0.2s;
    }
    .card-header .collapse-icon.collapsed { transform: rotate(-90deg); }

    /* Stream preview grid */
    .stream-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 12px;
    }
    .stream-card {
      background: #0a0a0a;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    .stream-card.selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent);
    }
    .stream-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      font-size: 12px;
    }
    .stream-card-header .stream-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
      color: var(--text-primary);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .stream-card-header .stream-title .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-tertiary);
      flex-shrink: 0;
    }
    .stream-card-header .stream-title .status-dot.live {
      background: var(--success);
      animation: pulse 1.5s infinite;
    }
    .stream-card-header .stream-title .status-dot.error {
      background: var(--danger);
    }
    .stream-card-header .stream-actions {
      display: flex;
      gap: 4px;
      flex-shrink: 0;
    }
    .stream-card-header .stream-actions button {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .stream-card-header .stream-actions button:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }
    .stream-card-header .stream-actions button.active {
      background: var(--success);
      border-color: var(--success);
      color: white;
    }
    .stream-card-header .stream-actions button.active:hover {
      background: #16a34a;
    }
    .stream-viewport {
      position: relative;
      aspect-ratio: 16/9;
      background: #000;
    }
    .stream-viewport img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }
    .stream-viewport .stream-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      background: rgba(0,0,0,0.9);
      color: var(--text-tertiary);
      font-size: 11px;
    }
    .stream-viewport .stream-overlay.hidden { display: none; }
    .stream-viewport .stream-overlay .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    .stream-viewport .stream-overlay .play-icon {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .stream-viewport .stream-overlay .play-icon:hover {
      background: rgba(255,255,255,0.2);
      transform: scale(1.1);
    }
    .stream-viewport .stream-overlay .play-icon::after {
      content: '';
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 10px 0 10px 16px;
      border-color: transparent transparent transparent rgba(255,255,255,0.8);
      margin-left: 4px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .stream-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 12px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      font-size: 10px;
      color: var(--text-tertiary);
    }
    .stream-footer .live-badge {
      background: var(--danger);
      color: white;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .stream-footer .stream-meta {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .stream-empty {
      padding: 40px 20px;
      text-align: center;
      color: var(--text-tertiary);
      font-size: 12px;
    }

    /* Orphaned processes section */
    .orphaned-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      margin-top: 8px;
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.2);
      border-radius: 4px 4px 0 0;
      font-size: 12px;
      color: var(--text-secondary);
    }
    .orphaned-header + .card-inner {
      border-top: none;
      border-radius: 0 0 4px 4px;
      border-color: rgba(239, 68, 68, 0.2);
    }
    .orphaned-row {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      font-size: 12px;
      background: rgba(239, 68, 68, 0.03);
    }
    .orphaned-row:last-child { border-bottom: none; }
    .orphaned-row:hover { background: rgba(239, 68, 68, 0.08); }
    .orphaned-row .orphan-info {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .orphaned-row .orphan-pid {
      font-family: monospace;
      color: var(--danger);
      font-weight: 500;
    }
    .orphaned-row .orphan-port {
      color: var(--text-secondary);
    }
    .orphaned-row .orphan-memory {
      color: var(--text-tertiary);
      font-size: 11px;
    }
    .orphaned-row .orphan-config {
      flex: 1;
      color: var(--text-tertiary);
      font-size: 11px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 200px;
    }
  </style>
</head>
<body>
  <header>
    <h1>GSPlay</h1>
    <div id="status"></div>
  </header>

  <main>
    <div class="error" id="error"></div>

    <!-- Launch Settings -->
    <div class="card">
      <div class="card-header">Launch Settings</div>
      <div class="card-body">
        <div class="form-row">
          <div class="form-group">
            <label>GPU</label>
            <select id="gpu" style="width: 480px;"></select>
          </div>
          <div class="form-group">
            <label>Instance Name</label>
            <input type="text" id="instanceName" placeholder="Auto" style="width: 150px;">
          </div>
          <div class="form-group">
            <label>Port</label>
            <input type="number" id="instancePort" placeholder="Auto" style="width: 80px;">
          </div>
          <div class="form-group">
            <label>Options</label>
            <div style="display: flex; gap: 8px;">
              <button type="button" class="toggle-btn active" id="compactBtn" onclick="toggleOption('compact')">Compact</button>
              <button type="button" class="toggle-btn active" id="viewOnlyBtn" style="display: none;" onclick="toggleOption('viewOnly')">View Only</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- File Browser -->
    <div class="card" id="browserCard" style="display: none;">
      <div class="card-header">File Browser</div>
      <div class="card-body">
        <div class="path-bar">
          <div class="breadcrumb" id="breadcrumb"></div>
        </div>
        <div class="card-inner" id="fileList"></div>
      </div>
    </div>

    <!-- Instances -->
    <div class="card">
      <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
        <span>Instances <span id="instanceCount" style="font-weight: normal;"></span></span>
        <span style="display: flex; gap: 6px; align-items: center;">
          <button class="btn-secondary btn-sm" onclick="scanProcesses()" id="scanBtn" title="Scan for orphaned processes">Scan</button>
        </span>
      </div>
      <div class="card-body">
        <div class="card-inner" id="instancesTable"></div>
        <div id="orphanedSection" style="display: none;">
          <div class="orphaned-header">
            <span>Orphaned Processes <span id="orphanedCount" class="text-muted"></span></span>
            <span style="display: flex; gap: 4px;">
              <button class="btn-danger btn-sm" onclick="stopAllOrphaned(false)" title="Stop all orphaned">Stop All</button>
              <button class="btn-danger btn-sm" onclick="stopAllOrphaned(true)" title="Force kill all">Force</button>
            </span>
          </div>
          <div class="card-inner" id="orphanedTable"></div>
        </div>
      </div>
    </div>

    <!-- Stream Previews -->
    <div class="card" id="streamPreviewCard" style="display: none;">
      <div class="card-header collapsible" onclick="toggleStreamPanel()">
        <span>
          Streams
          <span class="console-instance-name" id="streamCount"></span>
        </span>
        <span style="display: flex; gap: 8px; align-items: center;">
          <button class="btn-secondary btn-sm" onclick="event.stopPropagation(); startAllStreams()" title="Start all streams">Start All</button>
          <button class="btn-secondary btn-sm" onclick="event.stopPropagation(); stopAllStreams()" title="Stop all streams">Stop All</button>
          <span class="collapse-icon" id="streamCollapseIcon">‚ñº</span>
        </span>
      </div>
      <div class="card-body" id="streamPreviewBody">
        <div class="stream-grid" id="streamGrid">
          <div class="stream-empty">No streaming instances available</div>
        </div>
      </div>
    </div>

    <!-- Console -->
    <div class="card">
      <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
        <span>
          <span class="console-status" id="consoleStatus"></span>
          Console
          <span class="console-instance-name" id="consoleInstanceName">‚Äî Select an instance</span>
        </span>
        <span style="display: flex; gap: 6px;">
          <button class="btn-secondary btn-sm" onclick="clearConsole()">Clear</button>
          <button class="btn-secondary btn-sm" id="autoScrollBtn" onclick="toggleAutoScroll()">Auto-scroll: ON</button>
        </span>
      </div>
      <div class="card-body">
        <div class="card-inner compact console-content" id="consoleBody">
          <div class="console-empty">Click on an instance row to view its console output</div>
        </div>
      </div>
    </div>
  </main>

  <script>
    const API = '/api';
    let gpuInfo = null;
    let systemStats = null;
    let browseConfig = null;
    let instances = [];

    // Console state
    let selectedInstanceId = null;
    let logEventSource = null;
    let autoScroll = true;
    const MAX_LOG_LINES = 1000;

    // Error handling
    function showError(msg) {
      const el = document.getElementById('error');
      el.textContent = msg;
      el.style.display = 'block';
      setTimeout(() => el.style.display = 'none', 5000);
    }

    // Toggle button state
    function toggleOption(name) {
      const btn = document.getElementById(name + 'Btn');
      btn.classList.toggle('active');
    }

    // System Stats
    async function fetchSystemStats() {
      try {
        const res = await fetch(`${API}/system`);
        if (res.ok) {
          systemStats = await res.json();
          updateStatusBar();
        }
      } catch (e) {
        console.error('Failed to load system stats');
      }
    }

    // GPU Info
    async function fetchGpuInfo() {
      try {
        const res = await fetch(`${API}/gpu`);
        if (res.ok) {
          gpuInfo = await res.json();
          renderGpuSelect();
          updateStatusBar();
        }
      } catch (e) {
        console.error('Failed to load GPU info');
      }
    }

    function updateStatusBar() {
      let parts = [];
      if (systemStats) {
        parts.push(`CPU: ${systemStats.cpu_percent.toFixed(0)}%`);
        parts.push(`RAM: ${systemStats.memory_used_gb}/${systemStats.memory_total_gb} GB`);
      }
      if (gpuInfo) {
        parts.push(`Driver: ${gpuInfo.driver_version}`);
        parts.push(`CUDA: ${gpuInfo.cuda_version}`);
      }
      if (browseConfig?.external_url) {
        parts.push(`<span style="color: var(--accent);">External</span>`);
      }
      document.getElementById('status').innerHTML = parts.join(' <span style="color: var(--text-tertiary);">|</span> ');
    }

    function renderGpuSelect() {
      if (!gpuInfo?.gpus?.length) return;

      const select = document.getElementById('gpu');
      select.innerHTML = gpuInfo.gpus.map(g => {
        const memPct = Math.round(g.memory_used / g.memory_total * 100);
        return `<option value="${g.index}">GPU ${g.index}: ${g.name} | ${g.memory_used}/${g.memory_total} MB (${memPct}%) | ${g.utilization}% util | ${g.temperature}¬∞C</option>`;
      }).join('');
    }

    // Browse config
    async function fetchBrowseConfig() {
      try {
        const res = await fetch(`${API}/browse/config`);
        browseConfig = await res.json();

        if (browseConfig.enabled) {
          document.getElementById('browserCard').style.display = 'block';
          fetchBrowsePath('');
        }

        // Show view-only button only if not forced by CLI
        if (!browseConfig.view_only) {
          document.getElementById('viewOnlyBtn').style.display = 'inline-block';
        }

        updateStatusBar();
      } catch (e) { console.error(e); }
    }

    // File browser
    async function fetchBrowsePath(path) {
      try {
        const res = await fetch(`${API}/browse?path=${encodeURIComponent(path)}`);
        if (!res.ok) throw new Error((await res.json()).detail);
        const data = await res.json();
        renderBrowser(data, path);
      } catch (e) { showError(e.message); }
    }

    let currentBrowsePath = '';

    function renderBrowser(data, currentPath) {
      currentBrowsePath = currentPath;
      const parts = currentPath.split('/').filter(p => p);
      const isAtRoot = parts.length === 0;

      // Breadcrumb
      let breadcrumb = `<a onclick="fetchBrowsePath('')">root</a>`;
      let acc = '';
      parts.forEach(p => {
        acc += (acc ? '/' : '') + p;
        const path = acc;
        breadcrumb += ` <span>/</span> <a onclick="fetchBrowsePath('${path}')">${escapeHtml(p)}</a>`;
      });
      document.getElementById('breadcrumb').innerHTML = breadcrumb;

      // File list
      const dirs = data.entries.filter(e => e.is_directory);

      // Build HTML with optional parent directory entry
      let html = '';

      // Add "../" entry if not at root
      if (!isAtRoot) {
        const parentPath = parts.slice(0, -1).join('/');
        html += `
          <div class="file-item" onclick="fetchBrowsePath('${parentPath}')">
            <span class="file-icon">üìÅ</span>
            <span class="file-name">..</span>
            <span class="file-meta"></span>
          </div>
        `;
      }

      if (!dirs.length && isAtRoot) {
        document.getElementById('fileList').innerHTML =
          '<div class="empty-state">Empty directory</div>';
        return;
      }

      html += dirs.map(e => {
        const icon = e.is_ply_folder ? 'üì¶' : 'üìÅ';
        const isEmpty = !e.is_ply_folder && e.subfolder_count === 0;
        let meta = '';
        if (e.is_ply_folder) {
          meta = `${e.ply_count} PLY, ${e.total_size_mb.toFixed(1)} MB`;
        } else if (e.subfolder_count > 0) {
          meta = `${e.subfolder_count} folder${e.subfolder_count > 1 ? 's' : ''}`;
        } else {
          meta = 'empty';
        }
        const actions = e.is_ply_folder ? `
          <div class="file-actions">
            <button class="btn-success btn-sm" onclick="event.stopPropagation(); launchFolder('${escapeHtml(e.path)}', '${escapeHtml(e.name)}')">Launch</button>
          </div>
        ` : '';

        const clickHandler = isEmpty ? '' : `onclick="fetchBrowsePath('${escapeHtml(e.path)}')"`;
        const classes = `file-item ${e.is_ply_folder ? 'ply-folder' : ''} ${isEmpty ? 'disabled' : ''}`;

        return `
          <div class="${classes}" ${clickHandler}>
            <span class="file-icon">${icon}</span>
            <span class="file-name">${escapeHtml(e.name)}</span>
            <span class="file-meta">${meta}</span>
            ${actions}
          </div>
        `;
      }).join('');

      document.getElementById('fileList').innerHTML = html;
    }

    async function launchFolder(path, name) {
      const useExternal = browseConfig?.external_url;
      // Use forced view_only from CLI, or button state
      const viewOnly = browseConfig?.view_only || document.getElementById('viewOnlyBtn').classList.contains('active');
      const compact = document.getElementById('compactBtn').classList.contains('active');
      const portVal = document.getElementById('instancePort').value;
      const port = portVal ? parseInt(portVal) : null;

      const data = {
        path: path,
        name: document.getElementById('instanceName').value.trim() || name,
        port: port,
        stream_port: -1,  // Always enabled (-1 = auto-assign to viser_port + 1)
        gpu: parseInt(document.getElementById('gpu').value) || 0,
        compact: compact,
        view_only: viewOnly,
        cache_size: 100
      };

      try {
        const endpoint = useExternal ? `${API}/browse/launch?external_url=true` : `${API}/browse/launch`;
        const res = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        if (!res.ok) throw new Error((await res.json()).detail);
        await fetchInstances();
      } catch (e) { showError(e.message); }
    }

    // Instances
    async function fetchInstances() {
      try {
        const res = await fetch(`${API}/instances`);
        const data = await res.json();
        instances = data.instances;
        renderInstances();
      } catch (e) { showError('Failed to fetch instances'); }
    }

    function renderInstances() {
      const active = instances.filter(i => ['running', 'starting'].includes(i.status)).length;
      document.getElementById('instanceCount').textContent = `${active} active / ${instances.length} total`;

      // Clean up streams for deleted instances and render stream grid
      cleanupOrphanedStreams();
      renderStreamGrid();

      if (!instances.length) {
        document.getElementById('instancesTable').innerHTML =
          '<div class="empty-state">No instances</div>';
        return;
      }

      const html = instances.map(i => {
        const isActive = ['running', 'starting', 'orphaned'].includes(i.status);
        const badgeClass = `badge-${i.status}`;
        const openUrl = browseConfig?.external_url
          ? `${browseConfig.external_url}/v/${i.id}/`
          : i.url;
        const isSelected = i.id === selectedInstanceId;

        // Stream URL uses encoded path for security
        // encoded_stream_path is already a full URL if external_url was set on backend
        const hasStream = isActive && i.encoded_stream_path;
        const streamUrl = hasStream ? i.encoded_stream_path : null;

        // Icons
        const copyIcon = `<svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>`;
        const openIcon = `<svg viewBox="0 0 24 24"><path d="M19 19H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/></svg>`;

        return `
          <div class="instance-item ${isSelected ? 'selected' : ''}" onclick="selectInstance('${i.id}')">
            <span class="instance-name">${escapeHtml(i.name)}</span>
            <span class="badge ${badgeClass}">${i.status}</span>
            <span class="instance-meta">:${i.port}${i.gpu !== null ? ` ‚Ä¢ GPU ${i.gpu}` : ''}${i.view_only ? ' ‚Ä¢ <span style="color: var(--accent);">View</span>' : ''}${i.compact ? ' ‚Ä¢ <span style="color: #a78bfa;">Compact</span>' : ''}</span>
            <span class="instance-actions">
              ${isActive ? `
                <span class="btn-group">
                  <button class="btn-success btn-sm" onclick="event.stopPropagation(); window.open('${openUrl}', '_blank')" title="Open viewer">Viewer</button>
                  <button class="btn-success btn-sm btn-icon" onclick="event.stopPropagation(); copyLink('${openUrl}', event)" title="Copy viewer URL">${copyIcon}</button>
                </span>
                ${hasStream ? `
                  <span class="btn-group">
                    <button class="btn-primary btn-sm" onclick="event.stopPropagation(); window.open('${streamUrl}', '_blank')" title="Open stream">Stream</button>
                    <button class="btn-primary btn-sm btn-icon" onclick="event.stopPropagation(); copyLink('${streamUrl}', event)" title="Copy stream URL">${copyIcon}</button>
                  </span>
                ` : ''}
                <button class="btn-danger btn-sm" onclick="event.stopPropagation(); deleteInstance('${i.id}')">Stop</button>
              ` : `
                <button class="btn-secondary btn-sm" onclick="event.stopPropagation(); deleteInstance('${i.id}')">Delete</button>
              `}
            </span>
          </div>
        `;
      }).join('');

      document.getElementById('instancesTable').innerHTML = html;
    }

    async function deleteInstance(id) {
      try {
        const res = await fetch(`${API}/instances/${id}`, { method: 'DELETE' });
        if (!res.ok) throw new Error('Failed to delete');
        await fetchInstances();
      } catch (e) { showError(e.message); }
    }

    function copyLink(url, event) {
      navigator.clipboard.writeText(url).then(() => {
        // Show brief "Copied!" feedback
        const btn = event?.target;
        if (btn) {
          const originalText = btn.textContent;
          btn.textContent = 'Copied!';
          btn.style.background = 'var(--success)';
          btn.style.color = 'white';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
            btn.style.color = '';
          }, 1000);
        }
      }).catch(() => showError('Failed to copy'));
    }

    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    // Cleanup functions
    let orphanedProcesses = [];

    async function scanProcesses() {
      const scanBtn = document.getElementById('scanBtn');
      scanBtn.textContent = 'Scanning...';
      scanBtn.disabled = true;

      try {
        const res = await fetch(`${API}/cleanup`);
        if (!res.ok) throw new Error('Failed to scan');
        const data = await res.json();

        // Filter out processes that are managed by the launcher (match by PID)
        const managedPids = new Set(instances.filter(i => i.pid).map(i => i.pid));
        orphanedProcesses = data.processes.filter(p => !managedPids.has(p.pid));

        renderOrphanedProcesses();
      } catch (e) {
        showError(e.message);
      } finally {
        scanBtn.textContent = 'Scan';
        scanBtn.disabled = false;
      }
    }

    function renderOrphanedProcesses() {
      const section = document.getElementById('orphanedSection');
      const table = document.getElementById('orphanedTable');
      const countEl = document.getElementById('orphanedCount');

      if (orphanedProcesses.length === 0) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';
      countEl.textContent = `(${orphanedProcesses.length})`;

      table.innerHTML = orphanedProcesses.map(p => {
        const portStr = p.port ? `Port ${p.port}` : 'Unknown port';
        const configStr = p.config_path ? p.config_path.split('/').pop() : '‚Äî';
        return `
          <div class="orphaned-row">
            <div class="orphan-info">
              <span class="orphan-pid">PID ${p.pid}</span>
              <span class="orphan-port">${portStr}</span>
              <span class="orphan-memory">${p.memory_mb} MB</span>
              <span class="orphan-config" title="${escapeHtml(p.config_path || '')}">${escapeHtml(configStr)}</span>
            </div>
            <span style="display: flex; gap: 4px;">
              <button class="btn-danger btn-sm" onclick="stopOrphanedProcess(${p.pid}, false)" title="Stop gracefully">Stop</button>
              <button class="btn-danger btn-sm" onclick="stopOrphanedProcess(${p.pid}, true)" title="Force kill">Force</button>
            </span>
          </div>
        `;
      }).join('');
    }

    async function stopOrphanedProcess(pid, force) {
      try {
        const res = await fetch(`${API}/cleanup/stop`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ force: force, pid: pid })
        });
        if (!res.ok) throw new Error('Failed to stop process');

        // Remove from local list immediately for responsiveness
        orphanedProcesses = orphanedProcesses.filter(p => p.pid !== pid);
        renderOrphanedProcesses();

        // Refresh instances in case it was actually managed
        await fetchInstances();
      } catch (e) {
        showError(e.message);
      }
    }

    async function stopAllOrphaned(force) {
      if (orphanedProcesses.length === 0) return;

      const action = force ? 'force kill' : 'stop';
      if (!confirm(`${action.charAt(0).toUpperCase() + action.slice(1)} ${orphanedProcesses.length} orphaned process${orphanedProcesses.length > 1 ? 'es' : ''}?`)) {
        return;
      }

      try {
        // Stop each orphaned process
        for (const p of orphanedProcesses) {
          await fetch(`${API}/cleanup/stop`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ force: force, pid: p.pid })
          });
        }

        orphanedProcesses = [];
        renderOrphanedProcesses();
        await fetchInstances();
      } catch (e) {
        showError(e.message);
      }
    }

    // Multi-stream preview state
    let streamPanelCollapsed = false;
    let activeStreams = new Set(); // Instance IDs with active stream previews
    let streamWebSockets = new Map(); // Instance ID -> WebSocket
    let streamBlobUrls = new Map(); // Instance ID -> current blob URL (for cleanup)

    function toggleStreamPanel() {
      streamPanelCollapsed = !streamPanelCollapsed;
      const body = document.getElementById('streamPreviewBody');
      const icon = document.getElementById('streamCollapseIcon');
      body.style.display = streamPanelCollapsed ? 'none' : 'block';
      icon.classList.toggle('collapsed', streamPanelCollapsed);
    }

    function getStreamingInstances() {
      return instances.filter(i =>
        ['running', 'starting', 'orphaned'].includes(i.status) && i.encoded_stream_path
      );
    }

    function renderStreamGrid() {
      const card = document.getElementById('streamPreviewCard');
      const grid = document.getElementById('streamGrid');
      const countEl = document.getElementById('streamCount');

      const streamingInstances = getStreamingInstances();

      // Show/hide the card
      card.style.display = streamingInstances.length > 0 ? 'block' : 'none';
      countEl.textContent = streamingInstances.length > 0 ? `(${activeStreams.size}/${streamingInstances.length} active)` : '';

      if (streamingInstances.length === 0) {
        grid.innerHTML = '<div class="stream-empty">No streaming instances available</div>';
        return;
      }

      grid.innerHTML = streamingInstances.map(instance => {
        const isActive = activeStreams.has(instance.id);
        // For active streams, get current blob URL if available
        const currentBlobUrl = streamBlobUrls.get(instance.id) || '';

        return `
          <div class="stream-card ${isActive ? 'selected' : ''}" data-instance-id="${instance.id}">
            <div class="stream-card-header">
              <div class="stream-title">
                <span class="status-dot ${isActive ? 'live' : ''}" id="streamDot-${instance.id}"></span>
                <span>${escapeHtml(instance.name)}</span>
              </div>
              <div class="stream-actions">
                <button class="${isActive ? 'active' : ''}" onclick="event.stopPropagation(); toggleStream('${instance.id}')">${isActive ? 'Stop' : 'Start'}</button>
                <button onclick="event.stopPropagation(); window.open('${instance.encoded_stream_path}', '_blank')" title="Open in new tab">Open</button>
              </div>
            </div>
            <div class="stream-viewport" onclick="toggleStream('${instance.id}')">
              <img id="streamImg-${instance.id}" src="${currentBlobUrl}" style="display: ${isActive && currentBlobUrl ? 'block' : 'none'};">
              <div class="stream-overlay ${isActive && currentBlobUrl ? 'hidden' : ''}" id="streamOverlay-${instance.id}">
                ${isActive ? `
                  <div class="spinner" id="streamSpinner-${instance.id}"></div>
                  <span id="streamOverlayText-${instance.id}">Connecting...</span>
                ` : `
                  <div class="play-icon"></div>
                  <span>Click to start preview</span>
                `}
              </div>
            </div>
            <div class="stream-footer">
              <div>
                <span class="live-badge" id="liveBadge-${instance.id}" style="display: ${isActive && currentBlobUrl ? 'inline' : 'none'};">LIVE</span>
              </div>
              <div class="stream-meta">
                <span id="streamResolution-${instance.id}"></span>
                <span>:${instance.port}</span>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    function toggleStream(instanceId) {
      if (activeStreams.has(instanceId)) {
        stopStream(instanceId);
      } else {
        startStream(instanceId);
      }
    }

    function startStream(instanceId) {
      const instance = instances.find(i => i.id === instanceId);
      if (!instance || !instance.encoded_stream_path) return;

      // Close existing WebSocket if any
      if (streamWebSockets.has(instanceId)) {
        streamWebSockets.get(instanceId).close();
        streamWebSockets.delete(instanceId);
      }

      activeStreams.add(instanceId);

      // Update the card to show loading state
      const card = document.querySelector(`.stream-card[data-instance-id="${instanceId}"]`);
      if (card) {
        card.classList.add('selected');

        const img = document.getElementById(`streamImg-${instanceId}`);
        const overlay = document.getElementById(`streamOverlay-${instanceId}`);
        const toggleBtn = card.querySelector('.stream-actions button:first-child');

        if (overlay) {
          overlay.classList.remove('hidden');
          overlay.innerHTML = `
            <div class="spinner"></div>
            <span>Connecting...</span>
          `;
        }

        if (img) {
          img.style.display = 'none';
        }

        if (toggleBtn) {
          toggleBtn.textContent = 'Stop';
          toggleBtn.classList.add('active');
        }
      }

      // Create WebSocket connection
      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = instance.encoded_stream_path.replace(/^https?:/, wsProtocol).replace(/\/$/, '') + '/ws';
      const ws = new WebSocket(wsUrl);
      ws.binaryType = 'arraybuffer';

      ws.onopen = () => {
        console.log(`Stream WebSocket connected for ${instanceId}`);
      };

      ws.onmessage = (event) => {
        if (event.data instanceof ArrayBuffer) {
          // Binary JPEG frame
          const blob = new Blob([event.data], { type: 'image/jpeg' });
          const newUrl = URL.createObjectURL(blob);

          // Revoke previous blob URL to prevent memory leak
          const oldUrl = streamBlobUrls.get(instanceId);
          if (oldUrl) {
            URL.revokeObjectURL(oldUrl);
          }
          streamBlobUrls.set(instanceId, newUrl);

          const img = document.getElementById(`streamImg-${instanceId}`);
          const overlay = document.getElementById(`streamOverlay-${instanceId}`);
          const dot = document.getElementById(`streamDot-${instanceId}`);
          const liveBadge = document.getElementById(`liveBadge-${instanceId}`);
          const resolution = document.getElementById(`streamResolution-${instanceId}`);

          if (img) {
            img.src = newUrl;
            img.style.display = 'block';
            if (overlay) overlay.classList.add('hidden');
            if (dot) dot.className = 'status-dot live';
            if (liveBadge) liveBadge.style.display = 'inline';
            // Update resolution once we have the image dimensions
            img.onload = () => {
              if (img.naturalWidth && img.naturalHeight) {
                if (resolution) resolution.textContent = `${img.naturalWidth}√ó${img.naturalHeight}`;
              }
            };
          }
        }
      };

      ws.onerror = (error) => {
        console.error(`Stream WebSocket error for ${instanceId}:`, error);
        const overlay = document.getElementById(`streamOverlay-${instanceId}`);
        const dot = document.getElementById(`streamDot-${instanceId}`);
        const liveBadge = document.getElementById(`liveBadge-${instanceId}`);

        if (overlay) {
          overlay.classList.remove('hidden');
          overlay.innerHTML = `
            <span style="color: var(--danger);">Stream unavailable</span>
            <button class="btn-secondary btn-sm" onclick="event.stopPropagation(); retryStream('${instanceId}')" style="margin-top: 8px;">Retry</button>
          `;
        }
        if (dot) dot.className = 'status-dot error';
        if (liveBadge) liveBadge.style.display = 'none';
      };

      ws.onclose = () => {
        console.log(`Stream WebSocket closed for ${instanceId}`);
        streamWebSockets.delete(instanceId);
      };

      streamWebSockets.set(instanceId, ws);
      updateStreamCount();
    }

    function stopStream(instanceId) {
      activeStreams.delete(instanceId);

      // Close WebSocket connection
      const ws = streamWebSockets.get(instanceId);
      if (ws) {
        ws.close();
        streamWebSockets.delete(instanceId);
      }

      // Cleanup blob URL
      const blobUrl = streamBlobUrls.get(instanceId);
      if (blobUrl) {
        URL.revokeObjectURL(blobUrl);
        streamBlobUrls.delete(instanceId);
      }

      const card = document.querySelector(`.stream-card[data-instance-id="${instanceId}"]`);
      if (card) {
        card.classList.remove('selected');

        const img = document.getElementById(`streamImg-${instanceId}`);
        const overlay = document.getElementById(`streamOverlay-${instanceId}`);
        const dot = document.getElementById(`streamDot-${instanceId}`);
        const liveBadge = document.getElementById(`liveBadge-${instanceId}`);
        const resolution = document.getElementById(`streamResolution-${instanceId}`);
        const toggleBtn = card.querySelector('.stream-actions button:first-child');

        if (img) {
          img.src = '';
          img.style.display = 'none';
        }

        if (overlay) {
          overlay.classList.remove('hidden');
          overlay.innerHTML = `
            <div class="play-icon"></div>
            <span>Click to start preview</span>
          `;
        }

        if (dot) dot.className = 'status-dot';
        if (liveBadge) liveBadge.style.display = 'none';
        if (resolution) resolution.textContent = '';

        if (toggleBtn) {
          toggleBtn.textContent = 'Start';
          toggleBtn.classList.remove('active');
        }
      }

      updateStreamCount();
    }

    function retryStream(instanceId) {
      stopStream(instanceId);
      setTimeout(() => startStream(instanceId), 100);
    }

    function startAllStreams() {
      const streamingInstances = getStreamingInstances();
      streamingInstances.forEach(instance => {
        if (!activeStreams.has(instance.id)) {
          startStream(instance.id);
        }
      });
    }

    function stopAllStreams() {
      const activeIds = [...activeStreams];
      activeIds.forEach(id => stopStream(id));
    }

    function updateStreamCount() {
      const streamingInstances = getStreamingInstances();
      const countEl = document.getElementById('streamCount');
      countEl.textContent = streamingInstances.length > 0 ? `(${activeStreams.size}/${streamingInstances.length} active)` : '';
    }

    // Clean up streams for instances that no longer exist
    function cleanupOrphanedStreams() {
      const validIds = new Set(instances.map(i => i.id));
      const orphanedStreamIds = [...activeStreams].filter(id => !validIds.has(id));
      orphanedStreamIds.forEach(id => {
        // Close WebSocket
        const ws = streamWebSockets.get(id);
        if (ws) {
          ws.close();
          streamWebSockets.delete(id);
        }
        // Cleanup blob URL
        const blobUrl = streamBlobUrls.get(id);
        if (blobUrl) {
          URL.revokeObjectURL(blobUrl);
          streamBlobUrls.delete(id);
        }
        activeStreams.delete(id);
      });
    }

    // Console functions
    function selectInstance(instanceId) {
      if (selectedInstanceId === instanceId) return;

      selectedInstanceId = instanceId;
      const instance = instances.find(i => i.id === instanceId);

      // Update UI
      document.getElementById('consoleInstanceName').textContent = instance ? `‚Äî ${instance.name}` : '‚Äî Unknown';
      renderInstances(); // Re-render to update selection

      // Clear and load logs
      clearConsole();
      loadInitialLogs(instanceId);
      startLogStream(instanceId);
    }

    async function loadInitialLogs(instanceId) {
      try {
        const res = await fetch(`${API}/instances/${instanceId}/logs?lines=200`);
        if (!res.ok) throw new Error('Failed to load logs');
        const data = await res.json();

        const content = document.getElementById('consoleBody');
        content.innerHTML = '';

        if (data.lines.length === 0) {
          content.innerHTML = '<div class="console-empty">No logs yet</div>';
          return;
        }

        data.lines.forEach(line => appendLogLine(line));
        scrollToBottom();
      } catch (e) {
        console.error('Failed to load logs:', e);
        document.getElementById('consoleBody').innerHTML =
          '<div class="console-empty">Failed to load logs</div>';
      }
    }

    function startLogStream(instanceId) {
      // Close existing stream
      if (logEventSource) {
        logEventSource.close();
        logEventSource = null;
      }

      updateConsoleStatus('streaming');

      logEventSource = new EventSource(`${API}/instances/${instanceId}/logs/stream`);

      logEventSource.addEventListener('log', (event) => {
        appendLogLine(event.data);
        if (autoScroll) scrollToBottom();
      });

      logEventSource.onerror = () => {
        updateConsoleStatus('error');
        // Attempt to reconnect after delay
        setTimeout(() => {
          if (selectedInstanceId === instanceId) {
            startLogStream(instanceId);
          }
        }, 3000);
      };
    }

    function appendLogLine(line) {
      const content = document.getElementById('consoleBody');

      // Remove empty state message if present
      const emptyMsg = content.querySelector('.console-empty');
      if (emptyMsg) emptyMsg.remove();

      // Create log line element
      const lineEl = document.createElement('div');
      lineEl.className = 'log-line';

      // Color-code based on content
      const lowerLine = line.toLowerCase();
      if (lowerLine.includes('error') || lowerLine.includes('exception') || lowerLine.includes('traceback')) {
        lineEl.classList.add('error');
      } else if (lowerLine.includes('warning') || lowerLine.includes('warn')) {
        lineEl.classList.add('warning');
      } else if (lowerLine.includes('info')) {
        lineEl.classList.add('info');
      }

      lineEl.textContent = line;
      content.appendChild(lineEl);

      // Limit number of lines
      while (content.children.length > MAX_LOG_LINES) {
        content.removeChild(content.firstChild);
      }
    }

    function scrollToBottom() {
      const content = document.getElementById('consoleBody');
      content.scrollTop = content.scrollHeight;
    }

    function clearConsole() {
      const content = document.getElementById('consoleBody');
      content.innerHTML = '<div class="console-empty">Console cleared</div>';
    }

    function toggleAutoScroll() {
      autoScroll = !autoScroll;
      const btn = document.getElementById('autoScrollBtn');
      btn.textContent = `Auto-scroll: ${autoScroll ? 'ON' : 'OFF'}`;
    }

    function updateConsoleStatus(status) {
      const el = document.getElementById('consoleStatus');
      el.className = 'console-status';
      if (status) el.classList.add(status);
    }

    // Init
    fetchSystemStats();
    fetchGpuInfo();
    fetchBrowseConfig();
    fetchInstances();

    // Refresh
    setInterval(fetchInstances, 5000);
    setInterval(fetchSystemStats, 3000);
    setInterval(fetchGpuInfo, 10000);
  </script>
</body>
</html>
